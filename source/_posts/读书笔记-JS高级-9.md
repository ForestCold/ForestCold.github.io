---
title: 作用域的相关概念和垃圾回收机制
date: 2017-08-4 11:04:34
tags:
- 参数传递
- 作用域
- 垃圾回收
categories:
- 读书笔记
- JavaScript高级程序设计
---

``参数传递``    ``值传递``    ``引用传递``    ``作用域``    ``作用域链``    ``函数声明``    ``函数表达式``    ``变量提升``    ``执行上下文``    ``变量对象``    ``活动对象``    ``函数调用栈``    ``对应「JavaScript高级程序设计」中部分第四章和部分第七章``

<!--more-->

***

JavaScript中的作用域真的比原型还要难以理解，挣扎了两天好在总算是搞懂了。这一部分主要的难点之一在于出现了非常多新的概念，很容易把它们搞混。另一个主要的难点在于对闭包和this的理解，这一部分将在下一篇博文中进行整理。

# 参数传递机制

主要的参数传递机制包括 **按值传递** 和 **按引用传递**。两者的主要区别在于按值传递的话形参的值等于实参的值，按引用传递的话形参的值等于实参的地址。JavaScript中所有的参数传递方式都是按值传递，无论传递的是基本数据类型还是引用数据类型。

对于基本数据类型的按值传递非常好理解，形参的值自然等于实参的值，在函数内部对形参进行修改，是不会影响到函数外部实参的值的。可是对于引用类型，很多人会误认为它是按引用传递的，这么认为的理由是在函数内部对引用类型的形参的修改，能够影响到函数外部引用类型的实参的值。

但是需要注意的是，JavaScript中引用类型变量本身，保存的就是对象地址。因此将引用类型变量本身赋值给一个函数的形参时，赋值过去的就是对象的地址。函数在函数体中能够访问这个对象所在的内存空间，因此对它的修改才会反应到函数外部。以下代码能够证明引用类型是按值传递的：

```
function setName(object){
  object.name = "Yummy";
  object = new Object();
  object.name = "Magic";
}

var person = new Object();
setName(person);
alert(person.name); //"Yummy"
```
这段函数中对object的赋值操作无法影响到person.name属性，证明了object是按值传递的。如果person的属性被修改，打印出的是"Magic"的话，就证明object是按引用传递的。为什么呢？我们可以通过下图更清晰地了解。

![](https://raw.githubusercontent.com/ForestCold/image/master/du-9-1.jpg)

在按值传递的情况下，函数接收到的参数是person的值，这张图中是2这个值，对应了person所指向的对象的地址。当执行到第三行时，实际上是在另一个地址区新建了一个对象（这张图中在地址3中）。由于object的值是2，是一个堆内存中的地址，因此执行完这句话仅仅是将object的值变成了3而已，person中保存的仍然是地址2，所以person.name仍然是地址2处的name。

在按引用传递的情况下，函数接收到的参数是person的地址，这张图中对应1这个值。当执行第3句话时，在地址3处新建了一个对象，由于object是一个地址，给它赋值相当于给它所在的内存区域赋值，因此1这个地址的值由2变成了3，person的指向由图中的实线变成了虚线，此时打印出来的自然就是地址3处的name。

# 作用域的相关概念

JavaScript中的作用域包含非常多的概念。在ECMAScript5以及ECMAScript5之前JavaScript中没有块级作用域的概念，只有函数作用域和全局作用域。

## 执行上下文（Execution Context）

>**执行上下文**，有时候称为执行环境，指的是代码的运行环境。执行上下文和作用域的概念有所不同，作用域指的是当前执行上下文（也就是 **活动上下文** ）包含的 **变量对象** 。

执行上下文有两种情况确定。当浏览器开始执行一段JavaScript代码的时候，创建并进入的是全局执行上下文。每当一个函数被调用的时候，为其创建并进入一个函数执行上下文。这些执行上下文都按照次序保存在一个 **执行上下文栈** 中。每创建一个执行上下文就将它压栈，离开一个执行上下文就将它从栈中弹出。而处于栈顶的执行上下文被称为活动上下文，代表当前正在执行的代码的运行环境。

一个执行上下文中，包含了以下三个变量：
 * 变量对象（Variable object），包含当前执行作用域中的形参、变量声明和函数声明
 * 作用域链（Scope chain），指针链表，每一个节点都指向一个变量对象
 * this，将在下一篇博文中重点介绍

 下面来看看变量对象和作用域链是怎么回事。

## 变量对象

 > **变量对象** 是与执行上下文相关的数据作用域。它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明。

 当一个函数被调用的时候，在所有代码被执行之前，会先为它初始化一个执行上下文。在初始化执行上下文中的变量对象时，首先遍历这个函数定义部分的内容，将所有形参、变量声明（var开头）和函数声明（function开头）放到变量对象中，并将变量声明赋值为undefined，将函数声明赋值为函数名和函数。如果发现一个变量的名字和已声明的变量和函数相同就跳过它，如果发现一个函数的名字和已声明的函数相同就覆盖它。这个过程也称为 **变量提升** 或 **函数提升** 。

 特别需要注意的是，不以var和function进行声明的变量和函数将会被添加到全局作用域中。

 接着，函数中的代码会被执行，遇到变量对象中的变量则更新它的值。下面通过一个例子来深入理解这一过程。

 ```
 (function(){
    console.log(foo);     //undefined
    console.log(bar);     //function bar(){  console.log("bar");  }
    console.log(baz);     //function baz(){  console.log("baz");  }

    var foo = function(){};

    function bar(){
        console.log("bar");
    }

    var bar = 20;
    console.log(bar);     //20

    function baz(){
        console.log("baz");
    }

})()

```
这个例子中， (function(){...})()的语法是一个模拟块级作用域的语法，我们将在下一篇博文中详细介绍，这里只要理解这是一个作用域就行了。当进入这个作用域时，随即生成了一个执行上下文，其中的变量对象进行初始化。首先将所有var开头的变量声明加入变量对象并赋值undefined，然后将所有function开头的函数声明的名字和函数内容加入变量对象。

接着，代码开始执行。首先打印foo，由于foo是由var关键字打头的，因此在存入变量对象时被赋值为undefined，代码从作用域链的顶端，即当前变量对象中查找foo发现找到了，值为undefined，所以打印结果为undefined。第三行和第四行，分别在变量对象中查找bar函数和baz函数的函数声明，发现都找到了，分别打印。而第13行需要特别注意，因为当解释器执行到第12行时，变量对象中bar的值会被重置为20，因此第13行打印出的结果就是20。

## 作用域链

作用域链实质使一个链表，包含指向一堆变量对象的指针。它在一个执行上下文被创建的时候，首先拷贝上一层执行上下文的作用域链，然后将当前的变量对象放到原来的作用域链的顶端，并更新执行上下文中的指针，使之指向新添加进来的变量对象。

作用域链的链表头包含的变量对象，也就是当前执行上下文的变量对象，被称为 **活动对象** 。作用域链的作用是进行 **标识符解析**，说白了就是查找一个变量。标识符解析总是从作用域链的链表头开始，如果找到就取出并不再往下查找，找不到就接着往上找，一直找到作用域链的末端，也就是全局上下文的变量对象。如果整条作用域链中都找不到，就报告一个错误。

有两种特殊情况： try-catch语句中的catch块和with语句能够在作用域链头额外添加一个变量对象。
```
with(location) {
  ... //这个地方可以访问location中的所有属性和方法
}
```

关于执行上下文、变量对象和作用域链之间的关系，可以由下面的例子和图进行表示：
```
var scope = "global";
function CheckScope(){
    var scope = "local";
    return scope;
}
CheckScope();     //结果为local
```
![](http://upload-images.jianshu.io/upload_images/1846966-415de0df2377e436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

*例子来源：[bruce_zhou的简书](http://www.jianshu.com/p/181da2b57eb2)*

# 垃圾回收机制

JavaScript中普遍使用两种垃圾回收机制：
* **标记清除** 主动回收机制。首先为所有变量打上标记，接着去掉当前环境中的标记以及被当前环境中的变量引用的变量的标记，然后把所有打着标记的变量回收。
* **引用计数** 被动回收机制。跟踪每个值被引用的次数，当一个变量被引用次数为0时就将其回收。但是引用计数容易造成 **循环引用** 的问题，例如在IE中使用一个COM对象（Component Object Model，将在之后的BOM和DOM部分进行介绍）。
