---
title: 闭包、this对象和匿名函数
date: 2017-08-4 11:04:35
tags:
- 闭包
- 作用域
- this对象
- 函数
categories:
- 读书笔记
- JavaScript高级程序设计
---

``闭包``    ``匿名函数``    ``this对象``    ``模仿块级作用域``    ``分组操作符``    ``私有变量``    ``静态私有变量``    ``模块模式``    ``增强的模块模式``    ``对应「JavaScript高级程序设计」中部分第四章和部分第七章``

<!--more-->

***

这一部分接着上一篇博文继续讲解作用域方面的概念，不过，比起上一篇博文，这里的概念要难理解不少。

# 闭包

> *闭包* 是指有权访问另一个函数作用域中的变量的函数。常见的创建方式是在一个函数中创建另一个函数。

根据之前学过的作用域链，我们很容易理解闭包为什么能够访问外层函数中的变量。当一个函数中不包含其它函数时，执行完它之后它所对应的活动对象将被销毁。但包含闭包的函数，在外层函数被执行之后，活动对象仍然存在。这是因为内层闭包能够访问外层函数的变量，所以必须将它们保留下来。这是为什么不能滥用闭包的原因，滥用闭包会导致内存浪费。

下面我们用一个例子来说明闭包的作用。假设我们想在浏览器末端创建十个<a&#62;标签，点击标签弹出对应的序号。在不了解JavaScript中的作用域机制时，我们很可能会写成下面这样：

```
var i,a;
for (i = 0; i < 10; i++){
	a = document.createElement('a');
	a.innerHTML = i + '<br>';
	a.addEventListener('click', function(e) {
		e.preventDefault();                     //屏蔽click中的默认操作
		alert(i);
	})
	document.body.appendChild(a);
}
```
这段代码的执行的结果是点击所有标签，输出都为10。造成这一现象的原因是JavaScript中不存在块级作用域，所以i实际是一个全局变量，当调用 *alert(i);* 这个语句时，访问的是全局中的i，而在这段代码执行完之后i的值已经被设置为了10。正确的写法应该是这样：
```
var i,a;
for (i = 0; i < 10; i++){
  (function(i) {
  	a = document.createElement('a');
  	a.innerHTML = i + '<br>';
  	a.addEventListener('click', function(e) {
  		e.preventDefault();
  		alert(i);
  	})
  	document.body.appendChild(a);
	})(i);
};
```
这一段代码和上一段代码的不同之处，是在for循环的外部包了一层(function(i){})(i)匿名函数。后面的括号表示立即执行并且传入参数为i。这种写法实际上是用匿名函数来 **模拟块级作用域**。此时，i（匿名函数的参数i，而不是外面定义的变量i）就变成了这个块级作用域中的变量。当调用 *alert(i)* 时，根据作用域链的原理，首先访问的是匿名函数内部的i，此时的i就是正确的值。

* **匿名函数** 指的是没有函数名的函数，它的name属性为空。注意，函数名指的是function关键字后面的那个名字，对于一个函数表达式 *var fun = function(){}* 而言，fun只是一个指向它的变量，这个函数本身仍然是一个匿名函数。由于语法规定函数声明必须带有名字，所以匿名函数通常出现在函数表达式中。由于匿名函数不会被加入变量对象中，所以它们的作用域是全局作用域。当匿名函数被执行完毕，里面的变量会被立即销毁。

* **为什么不能写成function(i){}(i)?** 我们之前学过变量对象的初始化过程，当解释器找到一个function关键字时，就将它当做一个函数声明。然而，通过函数声明出来的函数必须有函数名，不能是匿名函数，所以这时候会抛出一个错误。解决方法就是将函数用小括号括起来。小括号其实是 **分组操作符** ，它内部的内容会被看做一个表达式。而它执行的结果就是这个表达式的返回值，当表达式中只有一个函数时返回值就是这个函数。

* **块级作用域的作用** 除了这个例子之外，块级作用域主要用来在全局变量中限制过多设置的全局对象。试想如果每个程序员都自己设置了一大堆全局变量，很容易引起变量名的冲突，这时候块级作用域就派上用场了。JQuery源码就是一个运用块级作用域的例子。

# this对象

JavaSript中的this对象只的是调用当前函数的对象。this对象是在函数调用的时候生成的（记得之前说过变量对象包含一个this对象，而变量对象是在函数调用时才生成的），和函数定义无关。对于所有全局变量和全局函数，由于它们是被挂到window对象上的，因此它们的this对象是window。而对于其它函数，this对象通常是这个函数执行时函数前面的点前面的那个对象。

* 通过构造函数new一个新的对象时会改变this的指向。new的过程： 首先开辟一块内存空间，将this指向这片内存。然后给this依次挂上构造函数里的属性和方法。最后返回this。

* 对于函数表达式而言，this指向的并不是它右边函数前面的点前面的对象，而是左边变量被谁调用就指向谁，一般来说指向window。

* 对于有返回值的构造函数而言，如果返回值是一个对象（除了null），this指向那个对象，如果返回值是一个值，this指向它构造出来的实例（这种情况和第一条一样）。

## 闭包中的this问题

闭包中的this是不会指向闭包外部的函数的，因为对this的搜索只局限于当前活动对象，不会随着作用域链向上搜索。来看书上的一个例子：
```
var name = "The Window";

var object = {
  name : "My object",
  getNameFunc : function() {
    return function() {
      return this.name;
    }
  }
};

alert(object.getNameFunc()()); //"The Window"
```
这一段代码中的this访问不到闭包外层函数，因此不会等于object。而匿名函数的this指向window，因此返回的是在window中定义的变量name。不过，就算返回的函数不是匿名函数输出也是一样，因为没有对象对它进行调用。要让this能够指向object只需：
```
var name = "The Window";

var object = {
  name : "My object",
  getNameFunc : function() {
    var that = this;
    return function(that) {
      return that.name;
    }
  }
};

alert(object.getNameFunc()()); //"The object"
```
这样，闭包就获得了object中this的值。

下面是一个让我纠结了整整一天的例子，最后发现纠结的点根本不在于this的问题，而在于表达式的问题，这里也顺便呈现以下：
```
var name  = "The Window";

var object = {
  name : "My Object",
  getName : function() {
    return this.name;
  }
};

object.getName();                     //"My Object"
(object.getName)();                   //"My Object"
(object.getName = object.getName)();  //"The Window"
```
让人纠结的是第11行和第12行的代码，我们之前说过一对小括号是一个分组操作符，实际上一对小括号会对应一个返回值。第11行这种情况返回值就是object.getName，而第12行的返回值是等式右边的object.getName。右边的object.getName实际上就是一个匿名函数（其实不匿名结果是一样的），这句话等价于：
```
(function() {
  return this.name;
})()
```
这个函数中的this指向的是window。

>对于a = b = c这个表达式来说，实际上等价于a = (b = c)，而(b = c)返回的是c不是b，因此a最终的值为c。

# 利用闭包构造私有变量

任何函数中定义的变量都可以被称为 **私有变量**，因为没法在函数外部访问这些变量。有权访问这些私有变量的方法被称为 **特权方法（privileged method）**。

## 构造函数中定义私有变量
将私有变量定义在构造函数中，并且前面不加上this.，而特权方法前面加上this.。好处是所有实例不共享私有变量，坏处是同一个特权方法在不同实例中占用不同内存（参见继承中的构造函数模式）。
```
function MyObject () {
  var privateVariable = 10;
  function privateFunction {
    return false;
  };

  this.publicMethod = function() {
    privateVariable++;
    return privateFunction();
  };
}
```

## 静态私有变量
通过一个匿名函数构造块级作用域，封装构造函数，并用原型编写特权方法。好处是特权方法在同一片内存中，坏处是所有实例共享私有变量（参见继承中的原型模式）。
```
(function() {
  var privateVariable = 10;
  function privateFunction {
    return false;
  };

  MyObject = function() { //构造函数
  };

  MyObject.prototype.publicMethod = function() {
    privateVariable++;
    return privateFunction();
  };
})();
```
这里需要注意的是构造函数的写法。如果我们写成函数声明或加上var关键字的函数表达式形式，这个构造函数都会变成块级作用域中的私有函数。显然，这样是不对的，所以我们将其设置为一个匿名函数，这样这个构造函数就是全局变量，在块级作用域外部可以用它来创建实例。

## 模块模式（module pattern）
这是一种为单例（singleton）创建私有变量的方法。单例就是只有一个实例的对象，通常通过字面量形式创建。
```
var singleton = function(){

  var privateVariable = 10;
  function privateFunction(){
    return false;
  }

  return {
    publicProperty: true,
    publicMethod: function(){
      privateVariable++;
      return privateFunction();
    }
  }
}();
```
这种创建方式的不足之处在于实例类型是object。如果需要规定一个实例类型，就要用到增强的模块模式。

## 增强的模块模式
```
var singleton = function(){

  var privateVariable = 10;
  function privateFunction(){
    return false;
  }

  var object = new customType(); //customType为想要继承的对象类型

  object.publicProperty: true,
  object.publicMethod: function(){
      privateVariable++;
      return privateFunction();
  }

  return object;
}();
```
和模块模式唯一的不同就是返回值是一个new出来的对象。
