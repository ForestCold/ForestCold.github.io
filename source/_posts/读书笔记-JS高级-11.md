---
title: BOM(浏览器对象模型)
date: 2017-08-07 19:41:43
tags:
- BOM
- 浏览器检测
categories:
- 读书笔记
- JavaScript高级程序设计
---

``BOM``    ``windo对象``    ``location对象``    ``navigator对象``    ``能力检测``    ``怪癖检测``    ``用户代理检测``    ``对应「JavaScript高级程序设计」中第八章和第九章``

<!--more-->

***

# BOM中的对象

BOM（浏览器对象模型）是HTML5规范中的一部分，在第一篇读书笔记中讲到，它与ECMAScript标准和DOM共同构成了JavaScript。BOM中包含的对象属性和方法主要用于和浏览器相关的操作，主要对象有window对象, location对象和navigator对象。

## window对象

> window对象表示浏览器的一个实例，即是JavaScript访问浏览器的接口，也是ECMAScript中定义的Global对象。

每一个框架都有自己的window对象，所有的框架组成了一个名为frames的数组。

前面说过全局变量等同于定义在window上的变量，但全局变量不能通过delete操作符删除，但定义在window上的变量可以。尝试访问未声明的变量会抛出错误，但是通过查询window对象可以知道某个可能未声明的变量是否存在。

* **窗口框架**

  以下代码将浏览器分成了一个topFrame窗口和两个互为兄弟窗口的leftFrame窗口和rightFrame窗口：
  ```
  <html>
    <head>
      <title>Frameset Example</title>
    </head>
    <frameset rows = "100, *">                           //按行分成了两个frame，一个高度为100，一个为剩下高度
      <frame src = "frame.htm" name = "topFrame">
      <frameset cols = "50%, 50%">                       //按列分成了两个frame，各占50%的宽度
        <frame src = "leftframe.htm" name = "leftFrame"> //htm和html后缀没有本质区别
        <frame src = "rightframe.htm" name = "rightFrame">
      </frameset>
    </frameset>
  </html>
  ```
  和框架有关的对象共三个：top对象（最外层框架，也就是浏览器窗口）、parent对象（某个框架的父对象）、self对象（和window对象没有区别）。

* **窗口大小和位置**

  无法跨浏览器获取浏览器窗口的大小。*Window.outerWidth* 获取浏览器窗口外部的宽度。表示整个浏览器窗口的宽度，包括侧边栏（如果存在）、窗口镶边（window chrome）和调正窗口大小的边框（window resizing borders/handles）。*window.innerWidth* 表示浏览器视口（viewport）宽度（单位：像素），如果存在垂直滚动条则包括它。*document.documentElement.clientWidth* 表示HTML文档所在窗口的当前宽度。

  *resizeTo()* 和 *resizeBy()* 可以调整浏览器窗口的大小。*resizeTo()* 接收参数为新的宽度和高度，*resizeBy()* 接收宽度为新的宽度高度与原宽度高度之差。

  跨域取得窗口左上角位置：
  ```
  var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;
  var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;
  ```
  *moveTo()* 接收新位置的x和y坐标值，*moveBy()* 接收水平和垂直方向上的移动像素数。

* **间歇调用和超时调用**

  *setTimeout()* 表示超时调用，作用域指向全局作用域。*setInterval()* 表示间歇调用，但是在实际开发中很少真正被使用，因为后一个调用可能在前一个调用结束之前开启。

  一般使用超时调用来模拟间歇调用：
  ```
  var num = 0;
  var max = 10;
  function incrementNumber() {
    num++;
    if (num < max){
      setTimeout(incrementNumber, 500);
    } else {
      alert("Done");
    }
  }
  ```
  一般认为这是一种间歇调用的最佳模式。在这个例子中，超时调用模拟的间歇调用的作用是每过一段时间增加一次num的值。

* **系统对话框**

  *alert()* 弹出只有OK按钮的警告框，*confirm()* 弹出有OK和CANCEL两个按钮的确认框，*prompt()* 弹出一个包含OK和CANCEL按钮，并且还有一个用户输入框的提示框。

## location对象

window.location和document.location引用同一个对象。
```
window.location("http: //www.hanfeilin.com");
location.href("http: //www.hanfeilin.com");
```
以上两行代码的效果是相同的，都是打开新的URL并在历史记录中生成一条记录。而使用 *location.replace(URL)* 方法可以在跳转到URL的同时禁用后退按钮。*location.reload()* 可以重新加载当前页面，如果括号中的参数为true，则指定向服务器中加载。

怎么解析URL地址？location对象包括 *location.protocal*，*location.host*，*location.pathname*，*location.search*,*location.hash* 等。protocal指的是协议，包括http协议和https协议。host是域名。pathname是路径。search是?后面的查询参数。hash是#后面的哈希内容。一般一个网址的构成为：协议 + 域名 + 路径 + ? + 查询参数 + # + 哈希内容。

## navigator对象

navigator中有一个plugins属性，记录了浏览器中安装的插件信息，可以循环遍历数组对比每个元素和要查找的插件名字来检测插件。但是这个方法对IE无效，在IE中只能使用ActiveXObject类型并创建特定插件实例来达到效果。并且，在IE中还必须知道插件的标识符。以下代码是在任意浏览器中检测FLASH插件的方法：
```
//在IE中无效
function hasPlugin(name) {
  name = name.toLowerCase();
  for (var i = 0; i < navigator.plugins.length; i++){
    if (navigator.plugins[i].name.toLowerCase().indexOf(name) > -1){
      return true;
    }
  }
  return false;
}

//检测IE中的插件
function hasIEPlugin(name) {
  try {
    new ActiveXObject (name);
    return true;
  } catch (ex) {
    return false;
  }
}

//检测所有浏览器中的FLASH插件
function hasFlash() {
  var result = hasPlugin("Flash");
  if (!result) {
    result = hasIEPlugin("ShockwaveFlash.ShockwaveFlash");
  }
  return result;
}
```
navigator还有个userAgent属性，在某些情况中可以检测浏览器类型：
```
var ua = navigator.userAgent;
var isChrome = ua.indexOf('Chrome');
```
但是并不保证所有情况都能检测出来，比如存在电子欺骗的情况。

## history对象
*history.go(某个数字)* 表示页面跳转，参数为正数就是向前跳转，为负数就是向后跳转。*hitsory.back()* 和 *history.forward()* 表示后退或前进一页。

# 客户端检测的几个概念

* **能力检测（特性检测）** 检测用来确定在当前浏览器环境中某个特性是否按照适当方式行事。一般用 *typeof x == function* 来进行检测。

* **怪癖检测（quirks detection）** 表示检测浏览器中某个特定的bug。

* **用户代理检测** 用户代理检测是为了对付电子欺骗（spoofing），通过检测用户代理字符串来识别浏览器。  
